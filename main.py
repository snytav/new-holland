# -*- coding: utf-8 -*-
"""Копия блокнота "FT_TS_Ameland.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xmVfMANupOYjc0AtHCSz22kd3-UaK4uT
"""

import math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt
import seaborn as sns
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
sns.set()

# from google.colab import drive
# drive.mount('/content/drive')
#
# import os
# from glob import glob
# os.chdir("/content/drive/MyDrive/Ameland")
# for file in glob("*"):
#
#     print(file)

f = open("Depth_12.dat","rt")

lines = f.readlines()
cmap = plt.get_cmap('gnuplot')
colors = [cmap(i) for i in np.linspace(0, 1, 56)]
print(lines)

# fig, ax = plt.subplots()
plt.figure()
colors = ['red', 'black', 'blue', 'brown', 'green','yellow','magenta','grey','cyan']
depth_along_years = []
years = []
distances_along_years = []

number =0
s = ''.join(lines)
years_list = s.split('}}')     # splitting along years
for y in years_list:

    if y == '\n':
        break
    year_and_depths = y.split('{{')
    year = year_and_depths[0].strip()
    years.append(year)
    depths = year_and_depths[1:]

    dists_and_depths = depths[0].split(',')
    print('dists and depths ', dists_and_depths)
    odds  = dists_and_depths[1::2]
    print('odds ',odds)
    evens = dists_and_depths[::2]
    print('evens ',evens)
    odds_cleared = [s.replace('}', '').replace('[', '').replace('{', '').replace('\n', '') for s in odds]
    evens_cleared = [s.replace('}', '').replace('{', '').replace('\n', '') for s in evens]
    odds_numbers = [float(s.strip()) for s in odds_cleared]
    evens_numbers  = [float(s.strip()) for s in evens_cleared]
    depth_along_years.append(odds_numbers)
    print('depth_along_years ',depth_along_years)

    distances_along_years.append(evens_numbers)
    print('distances_along_years ',distances_along_years)
    plt.plot(np.array(evens_numbers), np.array(odds_numbers), label=str(year), color=colors[number % len(colors)])
    plt.title(str(year))
    plt.show()

    plt.legend(loc='best')
    number = number + 1
    qq = 0

plt.xlabel('cross-shore distance')
plt.ylabel('depth')
plt.title('Coast profile')

def get_distance_cell_and_factor(d0,dist):
    i = 0
    f = 0.0
    #dist = distances_along_years[0]
    if d0 < np.max(dist) and d0 >= np.min(dist):
       for i,d in enumerate(dist):
           #print(i,d,d0)
           if d <= d0 and d0 <= dist[i+1]:
              f = (d0-d)/(dist[i+1]-dist[i])
              break
    return i,f

years = [int(y) for y in years]
years = np.array(years)
i,f = get_distance_cell_and_factor(1968.5,years)
print(i,f)

distances_along_years[0]

i,f = get_distance_cell_and_factor(45,distances_along_years[0])
print(i,f)

def interpolate(dep,i,f):
    t = dep[i]*(1.0-f)+dep[i+1]*f
    return t

years = [int(y) for y in years] # years.astype(int)
#years

#depth_along_years

def get_depth_exact_match(yt,m):
    for y,dis,dep in zip(years,distances_along_years,depth_along_years):
       #print(str(y),yt,dis,dep)
       if y == yt:
          #print(y,dis,dep)
          i,f = get_distance_cell_and_factor(m,dis)
          break
    t = interpolate(dep,i,f)
    return t

def get_depth(y,m):
    i_y, f_y = get_distance_cell_and_factor(y,years)
    d1 = get_depth_exact_match(years[i_y], m)
    d2 = get_depth_exact_match(years[i_y+1], m)
    dd = np.array([d1,d2])
    t = interpolate(dd, 0, f_y)
    return t


t = get_depth_exact_match(1968,45)
t = get_depth_exact_match(1968,4500)
print(t)
t = get_depth(1968,45)
print(t)


i,f = get_distance_cell_and_factor(1966,years)
#years
print(i,f)

for d in depth_along_years:
    print(len(d),d)

import numpy as np
cmap = plt.get_cmap('gnuplot')

qq = 0
dep = np.array(depth_along_years)
dis = np.array(distances_along_years)
qq = 0


lens = np.array([len(s) for s in dis])
observations = lens.min()
depths_uniform    = np.zeros((len(years),observations))
distances_uniform = np.zeros((len(years),observations))
for i in range(len(years)):
    for j in range(observations):
        depths_uniform[i][j]    = dep[i][j]
        distances_uniform[i][j] = dis[i][j]

num_years = [float(y) for y in years]
X,Y = np.meshgrid(num_years,distances_uniform[0])

np.savetxt('num_years.txt',num_years,fmt='%15.5e',delimiter='\n')
np.savetxt('dist_unif.txt',distances_uniform[0],fmt='%15.5e',delimiter='\n')

from matplotlib import cm
fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

X,Y = np.meshgrid(num_years,distances_uniform[0])

surf = ax.plot_surface(X, Y, depths_uniform.T, cmap=cm.coolwarm,
                       linewidth=0, antialiased=False)
ax.set_xlabel('YEAR')
ax.set_ylabel('DISTANCE')
fig.colorbar(surf, shrink=0.5, aspect=5)
plt.savefig('year_distance.png')
np.savetxt('dep.txt',depths_uniform,fmt = '%15.5e',delimiter='\n')

def loss_function(a,b):
    loss = 0.0
    for i,y in enumerate(years):
        for d in distances_along_years[i]:
            f = (a[0]+a[1]*y+a[2]*y**2 + a[3]*y**3+a[4]*y**4+
            b[0] + b[1] * d + b[2] * d ** 2 + b[3] * d ** 3 + b[4] * d ** 4)
            f1 = get_depth(y,d)
            loss += (f - f1)**2
    return loss

import autograd.numpy as np
from autograd import grad, jacobian
import autograd.numpy.random as npr

a = npr.randn(5)
b = npr.randn(5)

lmb = 0.01
for i in range(100):
    lf = loss_function(a,b)
    loss_grad = grad(loss_function)(a,b)
    a = a - lmb * loss_grad[0]
    b = b - lmb * loss_grad[1]
    print('iter ',i,lf)

qq = 0

